% =========
% DLAG DEMO 
% ========= 
%
% This demo shows how we can extract latent variables from multi-population
% data with DLAG (Gokcen et al., 2020). It's recommended to run this script
% section-by-section, rather than all at once (or put a break point before
% Section 2, as it may take a long time). Section 1 gives you time to go
% grab a coffee. Section 2 gives you time to take a long nap.
%
% Section 1 demsonstrates how DLAG can be used for exploratory data 
% analysis.
%
%     Section 1a fits a DLAG model with a specified number of within-
%     and across-group latent dimensions. Optional arguments are
%     explicitly specified for the sake of demonstration.
%
%     Section 1b takes this model and explores the latent GP timescales and
%     delays. It performs basic inference of within- and across-group 
%     latent trajectories. One can compare estimated parameters and
%     trajectories to the ground truth that underlies the demo synthetic
%     data.
%
%     Section 1c demonstrates how to orthonormalize and order latents 
%     according to various objectives, such as predictive power across
%     areas or shared variance explained within an area.
%
%     Section 1d demonstrates how to denoise observations using a DLAG
%     model. One can compare raw observations to their denoised
%     counterparts.
%
% Section 2 shows how to select optimal DLAG dimensionalities using 
% cross-validation. 
%
%     Section 2a uses cross-validation to first find optimal across-group
%     dimensionality according to a pCCA model (see example_pcca.m for
%     a detailed demo of pCCA). Applying pCCA or any related static method
%     first is recommended. It is much faster than DLAG, and if no 
%     significant interaction is found (i.e., pCCA cross-validation returns
%     0 across-group dimensions), then proceed no further.
%
%     Section 2b sweeps over DLAG across-group dimensionalities, while
%     keeping within-group dimensionalities fixed. learnDelays is set to 
%     false, so that delays are fixed at 0 during cross-validation. Fixing
%     delays during cross-validation provides a runtime benefit. Many of
%     the models during cross-validation will inevitably find spurious
%     across-group signals. In these cases, delay estimates can take many
%     EM iterations to converge (without much benefit).
%
%     Section 2c sweeps over a small range of across-group dimensionalities
%     around the optimal DLAG model from Section 2b, but allows delays to
%     be learned.
%
% Author: 
%     Evren Gokcen    egokcen@cmu.edu
%
% Last Revised: 
%     11 Apr 2020

%% ==================
% 0) Load demo data
% ======================

% Synthetic data generated from a DLAG model
dat_file = 'mat_sample/dlag_demo_data_synthetic';
fprintf('Reading from %s \n',dat_file);
load(dat_file);

%% =====================
% 1a) Fitting a DLAG model
% ========================

% Let's explicitly define all of the optional arguments, for 
% the sake of demonstration:
runIdx = 1;           % Results will be saved in baseDir/mat_results/runXXX/,  
                      % where XXX is runIdx. Use a new runIdx for each dataset.
datFormat = 'seq';    % Analyzing continuous valued data (e.g., spike counts)
baseDir = '.';        % Base directory where results will be saved
overwriteExisting = true; % Control whether existing results files are overwritten
saveData = false;     % Set to true to save train and test data (not recommended)
method = 'dlag';      % For now this is the only option, but that may change in the near future
binWidth = 20;        % Sample period / spike count bin width, in units of time (e.g., ms)
numFolds = 0;         % Number of cross-validation folds (0 means no cross-validation)
xDims_across = 4;     % This number of across-group latents matches the synthetic ground truth
xDims_within = {2,2}; % These numbers match the within-group latents in the synthetic ground truth
yDims = [10 10];      % Number of observed features (neurons) in each group (area)
rGroups = [1 2];      % For performance evaluation, we can regress Area 2's activity with Area 1
startTau = 2*binWidth;% Initial timescale, in the same units of time as binWidth
segLength = 30;       % Largest trial segment length, in no. of time points
init_method = 'pCCA'; % Initialize DLAG with fitted pCCA parameters
learnDelays = true;   % Set to false if you want to fix delays at their initial value
maxIters = 1e5;       % Limit the number of EM iterations (not recommended, in general)
freqLL = 10;          % Check for data log-likelihood convergence every freqLL EM iterations
freqParam = 100;      % Check for timescale and delay convergence every freqParam EM iterations
minVarFrac = 0.01;    % Private noise variances will not be allowed to go below this value
parallelize = false;  % Only relevant if cross-validating

fit_dlag(runIdx, Ytrain, ...
         'datFormat', datFormat, ...
         'baseDir', baseDir, ...
         'method', method, ...
         'binWidth', binWidth, ...
         'numFolds', numFolds, ...
         'xDims_across', xDims_across, ...
         'xDims_within', xDims_within, ...
         'yDims', yDims, ...
         'rGroups', rGroups,...
         'startTau', startTau, ...
         'segLength', segLength, ...
         'init_method', init_method, ...
         'learnDelays', learnDelays, ...
         'maxIters', maxIters, ...
         'freqLL', freqLL, ...
         'freqParam', freqParam, ...
         'minVarFrac', minVarFrac, ...
         'parallelize', parallelize, ...
         'overwriteExisting', overwriteExisting, ...
         'saveData', saveData);

%% =========================================================
% 1b) Explore extracted GP parameters and compare to ground truth
% ================================================================

% Retrieve the fitted model of interest
xDim_across = 4;
xDim_within = [2 2];
res = getModel_dlag(runIdx, xDim_across, xDim_within, ...
                    'baseDir', baseDir);

% Plot training progress of various quantities. These plots can help with
% troubleshooting, if necessary.
plotFittingProgress(res, ...
                    'freqLL', freqLL, ...
                    'freqParam', freqParam, ...
                    'units', 'ms');

% Plot estimated within-group GP timescales
plotGPparams_dlag(res.estParams, res.binWidth, res.rGroups, ...
                  'plotAcross', false, ...
                  'plotWithin', true, ...
                  'units', 'ms');
              
% Plot ground truth within-group GP timescales. 
% Note that latent variables are not, in general, ordered. So don't try to
% match estimated latent 1 to ground truth latent 1, and so on.
plotGPparams_dlag(trueParams, res.binWidth, res.rGroups, ...
                  'plotAcross', false, ...
                  'plotWithin', true, ...
                  'units', 'ms');

% Plot estimated and ground truth delays and across-group GP timescales
% together on the same plot. For these scatterplots, it's more
% straightforward to match ground truth latents to corresponding
% estimates.
plotGPparams_withGT_dlag(res.estParams, trueParams, res.binWidth,...
                         res.rGroups, 'units', 'ms');

% Plot unordered latents but maintain delay labels
[seqTest, ~] = exactInferenceWithLL_dlag(Ytest.seq, res.estParams);
plotEachDimVsTime(seqTest, 'xsm', res.binWidth, ...
                  'nPlotMax', 1, ...
                  'plotSingle', true, ...
                  'plotMean', true, ...
                  'units', 'ms', ...
                  'dlagFormat', true, ...
                  'params', res.estParams);

% Plot ground truth latents, in the same format as above.
% Note that latent variables are not, in general, ordered. So don't try to
% match estimated latent 1 to ground truth latent 1, and so on.
plotEachDimVsTime(Xtest.seq, 'xgt', res.binWidth, ...
                  'nPlotMax', 1, ...
                  'plotSingle', true, ...
                  'plotMean', true, ...
                  'units', 'ms', ...
                  'dlagFormat', true, ...
                  'params', trueParams);

%% ===============================================================
% 1c) Orthonormalize latent trajectories according to various objectives
% =======================================================================   

% Orthonormalize and order across-area latents according to predictive
% power. This loses information about individual delay/timescale labels.
[seqTest, Cpred] = predictiveProjection_dlag(seqTest, ...
                                             res.estParams, ...
                                             res.xDim_across, ...
                                             res.rGroups);

% Name of orthonormalized latents in seqTest  
xspec = sprintf('xorth_pred%02d', res.xDim_across);                                      
plotEachDimVsTime(seqTest, xspec, res.binWidth, ...
                  'nPlotMax', 20, ...
                  'nCol', res.xDim_across, ...
                  'plotSingle', true, ...
                  'plotMean', true, ...
                  'units', 'ms');
              
% Visualize the top three orthonormalized latents in 3D space
plotTraj(seqTest, xspec, ...
         'dimsToPlot', 1:3, ...
         'nPlotMax', 1, ...
         'plotSingle', true, ...
         'plotMean', true);
     
% Alternatively, orthonormalize and order latents according to overall 
% shared variance within each area. One can also focus on shared variance
% due only to across-group latents or within-group latents.
includeAcross = true;
includeWithin = true;
[seqTest, Corth] = orthonormalizeWithinGroups(seqTest, res.estParams, ...
                                              'includeAcross', includeAcross, ...
                                              'includeWithin', includeWithin);
xspec = 'xorth'; % This name changes depending on includeAcross/includeWithin
if includeAcross
    xspec = sprintf('%s_across', xspec);
end
if includeWithin
    xspec = sprintf('%s_within', xspec);
end                                 
plotEachDimVsTime(seqTest, xspec, res.binWidth, ...
                  'nPlotMax', 20, ...
                  'nCol', res.xDim_across + res.xDim_within(1), ...
                  'plotSingle', true, ...
                  'plotMean', true, ...
                  'units', 'ms');                       

%% =======================================
% 1d) Denoise observations using a DLAG model
% ============================================

% Denoise observations
[seqTest, ~, ~] = denoise_dlag(seqTest, res.estParams);

% Compare PSTHs of raw observations to PSTHs of denoised observations
psth_raw = get_psth(seqTest, 'spec', 'y');
psth_denoised = get_psth(seqTest, 'spec', 'yDenoised');
plotSeqRaster(psth_raw, res.binWidth, 'units', 'ms');
plotSeqRaster(psth_denoised, res.binWidth, 'units', 'ms');

%% =========================================================
% 2a) Cross-validate pCCA models to make sure there's significant
%     across-group interaction
%  ===============================================================

% If parallelize is true, all folds will be run in parallel using Matlab's
% parfor construct. If you have access to multiple cores, this provides
% significant speedup.
parallelize = false;
numWorkers = 2;      % Adjust this to your computer's specs

% Change other input arguments as appropriate
runIdx = 2;
numFolds = 4;
xDim = 0:min(yDims); % Sweep over these dimensionalities

fit_pcca(runIdx, Ytrain, ...
         'datFormat', datFormat, ...
         'baseDir', baseDir, ...
         'binWidth', binWidth, ...
         'numFolds', numFolds, ...
         'xDim', xDim, ...
         'yDims', yDims, ...
         'rGroups', rGroups,...
         'parallelize', parallelize, ...
         'numWorkers', numWorkers, ...
         'overwriteExisting', overwriteExisting, ...
         'saveData', saveData);
      
%% Get cross-validation results
[cvResults, bestModel] = getCrossValResults_pcca(runIdx, 'baseDir', baseDir);

% Plot cross-validated performance vs estimated dimensionality
% Data log-likelihood is the standard performance metric. pCCA can also be
% used for regression between groups. To see cross-validated performance of
% pCCA as a regression method, set plotR2 and/or plotMSE to true.
plotPerfvsDim_pcca(cvResults, ...
                   'bestModel', bestModel, ...
                   'plotLL', true, ...
                   'plotR2', false, ...
                   'plotMSE', false);

%% ================================================
% 2b) Cross-validate DLAG models with delays fixed at 0
%  =====================================================

% Change other input arguments as appropriate
runIdx = 2;
numFolds = 4;
xDims_across = 1:6;    % Sweep over these dimensionalities
xDims_within = {2 2};
learnDelays = false;   % During cross-validation, it's recommended to 
                       % not learn delays, for computational savings. Then
                       % re-fit the optimal model with non-zero delays.
       
fit_dlag(runIdx, Ytrain, ...
          'datFormat', datFormat, ...
          'baseDir', baseDir, ...
          'method', method, ...
          'binWidth', binWidth, ...
          'numFolds', numFolds, ...
          'xDims_across', xDims_across, ...
          'xDims_within', xDims_within, ...
          'yDims', yDims, ...
          'rGroups', rGroups,...
          'startTau', startTau, ...
          'segLength', segLength, ...
          'init_method', init_method, ...
          'learnDelays', learnDelays, ...
          'maxIters', maxIters, ...
          'freqLL', freqLL, ...
          'freqParam', freqParam, ...
          'minVarFrac', minVarFrac, ...
          'parallelize', parallelize, ...
          'numWorkers', numWorkers, ...
          'overwriteExisting', overwriteExisting, ...
          'saveData', saveData);
      
%% Get cross-validation results
[cvResults, bestModel] = getCrossValResults_dlag(runIdx, 'baseDir', baseDir);

% Plot cross-validated performance vs estimated dimensionality
% Data log-likelihood is the standard performance metric. DLAG can also be
% used for regression between groups. To see cross-validated performance of
% DLAG as a regression method, set plotR2 and/or plotMSE to true.
% If plotOrth is set to true, then regression performance will be shown for
% each dimension of the orthonormalized best-performing DLAG model. 
plotAcross = true;
fixWithin = [2 2];
fixAcross = 4;
plotPerfvsDim_dlag(cvResults, bestModel, plotAcross, ...
                   'fixWithin', fixWithin, ...
                   'fixAcross', fixAcross, ...
                   'plotLL', true, ...
                   'plotR2', false, ...
                   'plotMSE', false, ...
                   'plotOrth', false);
               
%% ==========================================================
% 2c) Sweep over a small range around the optimal DLAG model, and
%     allow delays to be learned
%  ================================================================

% Change input arguments as appropriate
runIdx = 3;
numFolds = 4;  
xDim_across = cvResults(bestModel).xDim_across;
% Allowing for delays in the across-group latents can actually lead to
% optimal models with smaller numbers of across-group latents, so it's good
% to sweep over a small range around the optimal non-delayed model.
xDims_across = [xDim_across-1 xDim_across xDim_across+1];
learnDelays = true;

fit_dlag(runIdx, Ytrain, ...
          'datFormat', datFormat, ...
          'baseDir', baseDir, ...
          'method', method, ...
          'binWidth', binWidth, ...
          'numFolds', numFolds, ...
          'xDims_across', xDims_across, ...
          'xDims_within', xDims_within, ...
          'yDims', yDims, ...
          'rGroups', rGroups,...
          'startTau', startTau, ...
          'segLength', segLength, ...
          'init_method', init_method, ...
          'learnDelays', learnDelays, ...
          'maxIters', maxIters, ...
          'freqLL', freqLL, ...
          'freqParam', freqParam, ...
          'minVarFrac', minVarFrac, ...
          'parallelize', parallelize, ...
          'numWorkers', numWorkers, ...
          'overwriteExisting', overwriteExisting, ...
          'saveData', saveData);
      
%% Inspect refitResults, and repeat steps in Section 1 as desired
[refitResults, bestModel] = getCrossValResults_dlag(runIdx, 'baseDir', baseDir);

% Plot cross-validated performance vs estimated dimensionality
plotAcross = true;
fixWithin = [2 2];
fixAcross = 4;
plotPerfvsDim_dlag(refitResults, bestModel, plotAcross, ...
                   'fixWithin', fixWithin, ...
                   'fixAcross', fixAcross, ...
                   'plotLL', true, ...
                   'plotR2', false, ...
                   'plotMSE', false, ...
                   'plotOrth', false);
               
% Retrieve the fitted model of interest
res = getModel_dlag(runIdx, refitResults(bestModel).xDim_across, ...
                    refitResults(bestModel).xDim_within, ...
                    'baseDir', baseDir);

% Plot estimated within- and across-group GP timescales
plotGPparams_dlag(res.estParams, res.binWidth, res.rGroups, ...
                  'plotAcross', true, ...
                  'plotWithin', true, ...
                  'units', 'ms');
              